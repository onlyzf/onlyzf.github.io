<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Fan's life]]></title><description><![CDATA[A starter blog demonstrating what Gatsby can do.]]></description><link>https://onlyzf.com</link><generator>RSS for Node</generator><lastBuildDate>Fri, 26 Jul 2019 07:12:50 GMT</lastBuildDate><item><title><![CDATA[《SRE Google运维解密》]]></title><description><![CDATA[SRE 方法论 确保长期关注研发工作 Google 将 SRE 团队的运维工作限制在 50%以内。 SRE 处理运维工作的一项准则是：在每 8-12 小时的 on-call…]]></description><link>https://onlyzf.com/2019/sre/</link><guid isPermaLink="false">https://onlyzf.com/2019/sre/</guid><pubDate>Sat, 13 Jul 2019 08:53:00 GMT</pubDate><content:encoded>&lt;h2&gt;SRE 方法论&lt;/h2&gt;
&lt;h3&gt;确保长期关注研发工作&lt;/h3&gt;
&lt;p&gt;Google 将 SRE 团队的运维工作限制在 50%以内。&lt;/p&gt;
&lt;p&gt;SRE 处理运维工作的一项准则是：在每 8-12 小时的 on-call 轮值期间最多只处理两个紧急事件。&lt;/p&gt;
&lt;p&gt;所有的产品事故都应该有对应的事后总结，无论有没有触发报警。事后总结应该包括以下内容：事故发生、发现、解决的全过程，事故的根本原因，预防或者优化的解决方案。事后总结的目标是尽早发现和堵住漏洞，而不是通过流程去绕过和掩盖它们。&lt;/p&gt;
&lt;h3&gt;在保障服务 SLO 的前提下最大化迭代速度&lt;/h3&gt;
&lt;p&gt;一般来说，任何软件系统都不应该一味地追求 100%可靠
正确的可靠性目标，必须考虑以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于用户的使用习惯，服务器可靠性要达到什么程度用户才会满意？&lt;/li&gt;
&lt;li&gt;如果这项服务的可靠性程度不够，用户是否有其他的替代选择？&lt;/li&gt;
&lt;li&gt;服务的可靠程度是否会影响用户对这项服务的使用模式？&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[《Docker —— 从入门到实践》]]></title><description><![CDATA[Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker…]]></description><link>https://onlyzf.com/2015/docker/</link><guid isPermaLink="false">https://onlyzf.com/2015/docker/</guid><pubDate>Sun, 05 May 2019 09:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。&lt;/p&gt;
&lt;p&gt;Docker 的基础是 Linux 容器（LXC）等技术。&lt;/p&gt;
&lt;p&gt;在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。&lt;/p&gt;
&lt;p&gt;首先，Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。 其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。&lt;/p&gt;
&lt;p&gt;开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。&lt;/p&gt;
&lt;h2&gt;Docker 镜像&lt;/h2&gt;
&lt;p&gt;Docker 镜像就是一个只读的模板。&lt;/p&gt;
&lt;p&gt;例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。&lt;/p&gt;
&lt;p&gt;镜像可以用来创建 Docker 容器。&lt;/p&gt;
&lt;h2&gt;Docker 容器&lt;/h2&gt;
&lt;p&gt;Docker 利用容器来运行应用。&lt;/p&gt;
&lt;p&gt;容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。&lt;/p&gt;
&lt;p&gt;可以把容器看做是一个简易版的 Linux 环境（包括 root 用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。&lt;/p&gt;
&lt;p&gt;*注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。&lt;/p&gt;
&lt;h2&gt;Docker 仓库&lt;/h2&gt;
&lt;p&gt;仓库是集中存放镜像文件的场所。&lt;/p&gt;
&lt;h2&gt;获取镜像&lt;/h2&gt;
&lt;p&gt;可以使用 docker pull 命令来从仓库获取所需要的镜像。&lt;/p&gt;
&lt;h2&gt;列出本地镜像&lt;/h2&gt;
&lt;p&gt;使用 docker images 显示本地已有的镜像。
利用 Dockerfile 来创建镜像&lt;/p&gt;
&lt;h2&gt;镜像的实现原理&lt;/h2&gt;
&lt;p&gt;Docker 镜像是怎么实现增量的修改和维护的？ 每个镜像都由很多层次构成，Docker 使用 Union FS 将这些不同的层结合到一个镜像中去。&lt;/p&gt;
&lt;p&gt;通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下，另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。 Docker 在 AUFS 上构建的容器也是利用了类似的原理。&lt;/p&gt;
&lt;h2&gt;新建并启动&lt;/h2&gt;
&lt;p&gt;所需要的命令主要为 docker run。&lt;/p&gt;
&lt;p&gt;其中，-t 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。&lt;/p&gt;
&lt;h3&gt;守护态运行&lt;/h3&gt;
&lt;p&gt;更多的时候，需要让 Docker 容器在后台以守护态（Daemonized）形式运行。此时，可以通过添加 -d 参数来实现。&lt;/p&gt;
&lt;h2&gt;终止容器&lt;/h2&gt;
&lt;p&gt;可以使用 docker stop 来终止一个运行中的容器。
此外，当 Docker 容器中指定的应用终结时，容器也自动终止。&lt;/p&gt;
&lt;h2&gt;进入容器&lt;/h2&gt;
&lt;p&gt;attach 命令&lt;/p&gt;
&lt;h2&gt;删除容器&lt;/h2&gt;
&lt;p&gt;可以使用 docker rm 来删除一个处于终止状态的容器。&lt;/p&gt;
&lt;h2&gt;自动创建&lt;/h2&gt;
&lt;p&gt;自动创建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。&lt;/p&gt;
&lt;p&gt;有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。&lt;/p&gt;
&lt;p&gt;而自动创建允许用户通过 Docker Hub 指定跟踪一个目标网站（目前支持 GitHub 或 BitBucket）上的项目，一旦项目发生新的提交，则自动执行创建。&lt;/p&gt;
&lt;h2&gt;Docker 数据管理&lt;/h2&gt;
&lt;p&gt;数据卷容器&lt;/p&gt;
&lt;h2&gt;Docker 中的网络功能&lt;/h2&gt;
&lt;h3&gt;外部访问容器&lt;/h3&gt;
&lt;p&gt;容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。&lt;/p&gt;
&lt;h3&gt;容器互联&lt;/h3&gt;
&lt;p&gt;Docker 通过 2 种方式为容器公开连接信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境变量&lt;/li&gt;
&lt;li&gt;更新 /etc/hosts 文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。&lt;/p&gt;
&lt;p&gt;如果在企业内部应用，或者做多个物理主机的集群，可能需要将多个物理主机的容器组到一个物理网络中来，那么就需要将这个网桥桥接到我们指定的网卡上。&lt;/p&gt;
&lt;h2&gt;安全&lt;/h2&gt;
&lt;h3&gt;内核名字空间&lt;/h3&gt;
&lt;h3&gt;控制组&lt;/h3&gt;
&lt;p&gt;终极目标是改进 2 个重要的安全特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将容器的 root 用户映射到本地主机上的非 root 用户，减轻容器和主机之间因权限提升而引起的安全问题；&lt;/li&gt;
&lt;li&gt;允许 Docker 服务端在非 root 权限下运行，利用安全可靠的子进程来代理执行需要特权权限的操作。这些子进程将只允许在限定范围内进行操作，例如仅仅负责虚拟网络设定或文件系统管理、配置操作等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，建议采用专用的服务器来运行 Docker 和相关的管理服务（例如管理服务比如 ssh 监控和进程监控、管理工具 nrpe、collectd 等）。其它的业务服务都放到容器中去运行。&lt;/p&gt;
&lt;h2&gt;Dockerfile&lt;/h2&gt;
&lt;h3&gt;ONBUILD&lt;/h3&gt;
&lt;h2&gt;底层实现&lt;/h2&gt;
&lt;p&gt;Docker 底层的核心技术包括 Linux 上的名字空间（Namespaces）、控制组（Control groups）、Union 文件系统（Union file systems）和容器格式（Container format）。&lt;/p&gt;</content:encoded></item></channel></rss>