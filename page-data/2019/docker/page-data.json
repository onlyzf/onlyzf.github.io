{"componentChunkName":"component---src-templates-blog-post-js","path":"/2019/docker/","result":{"data":{"site":{"siteMetadata":{"title":"Fan's life"}},"markdownRemark":{"id":"5ac6b66d-7703-56ae-aa23-45d94317ddca","excerpt":"Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 首先，Docker…","html":"<p>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。</p>\n<p>Docker 的基础是 Linux 容器（LXC）等技术。</p>\n<p>在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p>\n<p>首先，Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。 其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。</p>\n<p>开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。</p>\n<h2>Docker 镜像</h2>\n<p>Docker 镜像就是一个只读的模板。</p>\n<p>例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。</p>\n<p>镜像可以用来创建 Docker 容器。</p>\n<h2>Docker 容器</h2>\n<p>Docker 利用容器来运行应用。</p>\n<p>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p>\n<p>可以把容器看做是一个简易版的 Linux 环境（包括 root 用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>\n<p>*注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。</p>\n<h2>Docker 仓库</h2>\n<p>仓库是集中存放镜像文件的场所。</p>\n<h2>获取镜像</h2>\n<p>可以使用 docker pull 命令来从仓库获取所需要的镜像。</p>\n<h2>列出本地镜像</h2>\n<p>使用 docker images 显示本地已有的镜像。\n利用 Dockerfile 来创建镜像</p>\n<h2>镜像的实现原理</h2>\n<p>Docker 镜像是怎么实现增量的修改和维护的？ 每个镜像都由很多层次构成，Docker 使用 Union FS 将这些不同的层结合到一个镜像中去。</p>\n<p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下，另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。 Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p>\n<h2>新建并启动</h2>\n<p>所需要的命令主要为 docker run。</p>\n<p>其中，-t 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。</p>\n<h3>守护态运行</h3>\n<p>更多的时候，需要让 Docker 容器在后台以守护态（Daemonized）形式运行。此时，可以通过添加 -d 参数来实现。</p>\n<h2>终止容器</h2>\n<p>可以使用 docker stop 来终止一个运行中的容器。\n此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>\n<h2>进入容器</h2>\n<p>attach 命令</p>\n<h2>删除容器</h2>\n<p>可以使用 docker rm 来删除一个处于终止状态的容器。</p>\n<h2>自动创建</h2>\n<p>自动创建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。</p>\n<p>有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。</p>\n<p>而自动创建允许用户通过 Docker Hub 指定跟踪一个目标网站（目前支持 GitHub 或 BitBucket）上的项目，一旦项目发生新的提交，则自动执行创建。</p>\n<h2>Docker 数据管理</h2>\n<p>数据卷容器</p>\n<h2>Docker 中的网络功能</h2>\n<h3>外部访问容器</h3>\n<p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。</p>\n<h3>容器互联</h3>\n<p>Docker 通过 2 种方式为容器公开连接信息：</p>\n<ul>\n<li>环境变量</li>\n<li>更新 /etc/hosts 文件</li>\n</ul>\n<p>当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>\n<p>如果在企业内部应用，或者做多个物理主机的集群，可能需要将多个物理主机的容器组到一个物理网络中来，那么就需要将这个网桥桥接到我们指定的网卡上。</p>\n<h2>安全</h2>\n<h3>内核名字空间</h3>\n<h3>控制组</h3>\n<p>终极目标是改进 2 个重要的安全特性：</p>\n<ul>\n<li>将容器的 root 用户映射到本地主机上的非 root 用户，减轻容器和主机之间因权限提升而引起的安全问题；</li>\n<li>允许 Docker 服务端在非 root 权限下运行，利用安全可靠的子进程来代理执行需要特权权限的操作。这些子进程将只允许在限定范围内进行操作，例如仅仅负责虚拟网络设定或文件系统管理、配置操作等。</li>\n</ul>\n<p>最后，建议采用专用的服务器来运行 Docker 和相关的管理服务（例如管理服务比如 ssh 监控和进程监控、管理工具 nrpe、collectd 等）。其它的业务服务都放到容器中去运行。</p>\n<h2>Dockerfile</h2>\n<h3>ONBUILD</h3>\n<h2>底层实现</h2>\n<p>Docker 底层的核心技术包括 Linux 上的名字空间（Namespaces）、控制组（Control groups）、Union 文件系统（Union file systems）和容器格式（Container format）。</p>","frontmatter":{"title":"《Docker —— 从入门到实践》","date":"May 05, 2019","description":"《Docker —— 从入门到实践》读书笔记"}},"previous":{"fields":{"slug":"/2018/2018-10-30-game-development/"},"frontmatter":{"title":"Game Development"}},"next":{"fields":{"slug":"/snippets/container/"},"frontmatter":{"title":"容器及编排"}}},"pageContext":{"id":"5ac6b66d-7703-56ae-aa23-45d94317ddca","previousPostId":"5c6714d3-2d47-5f88-aa44-3a64f18c879f","nextPostId":"e3576608-a0fe-5687-908e-0c59e9af5ea4"}},"staticQueryHashes":["2841359383","916993862"]}